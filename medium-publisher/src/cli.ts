#!/usr/bin/env node
/**
 * Neko-Arc Medium Publisher - CLI
 *
 * Command-line interface for publishing articles to Medium
 */

import { Command } from 'commander';
import * as dotenv from 'dotenv';
import * as fs from 'fs';
import * as path from 'path';
import chalk from 'chalk';
import { MediumPublisher } from './MediumPublisher';
import type { Article, PublishStatus, ContentFormat } from './types';

// Load environment variables
dotenv.config();

const program = new Command();

program
  .name('neko-medium-publish')
  .description('üêæ Neko-Arc Medium Publisher - Publish articles to Medium with AI power! Nyaa~')
  .version('1.0.0');

/**
 * Publish command
 */
program
  .command('publish')
  .description('Publish an article to Medium')
  .requiredOption('-f, --file <path>', 'Path to markdown or HTML file')
  .requiredOption('-t, --title <title>', 'Article title')
  .option('-s, --status <status>', 'Publish status: public, draft, unlisted', 'draft')
  .option('--format <format>', 'Content format: markdown, html', 'markdown')
  .option('--tags <tags>', 'Comma-separated tags', '')
  .option('--canonical <url>', 'Canonical URL')
  .option('--source <source>', 'Source: manual, ai-agent, automated', 'manual')
  .option('--generated-by <name>', 'Generated by (personality)', 'neko-arc')
  .option('--no-mongo', 'Disable MongoDB logging')
  .action(async (options) => {
    try {
      console.log(chalk.cyan('üêæ Neko-Arc Medium Publisher starting, nyaa~!\n'));

      // Validate environment variables
      const accessToken = process.env.MEDIUM_ACCESS_TOKEN;
      if (!accessToken) {
        console.error(chalk.red('‚ùå Error: MEDIUM_ACCESS_TOKEN not found in .env file'));
        console.log(chalk.yellow('üí° Get your token at: https://medium.com/me/settings/security'));
        process.exit(1);
      }

      // Read article content
      const filePath = path.resolve(options.file);
      if (!fs.existsSync(filePath)) {
        console.error(chalk.red(`‚ùå Error: File not found: ${filePath}`));
        process.exit(1);
      }

      const content = fs.readFileSync(filePath, 'utf-8');
      console.log(chalk.green(`‚úÖ Loaded article from: ${filePath}`));
      console.log(chalk.gray(`   Content length: ${content.length} characters\n`));

      // Parse tags
      const tags = options.tags
        ? options.tags.split(',').map((tag: string) => tag.trim())
        : [];

      // Create article
      const article: Article = {
        title: options.title,
        content,
        publishStatus: options.status as PublishStatus,
        contentFormat: options.format as ContentFormat,
        tags,
        canonicalUrl: options.canonical,
      };

      // Initialize publisher
      const enableMongo = options.mongo !== false;
      const publisher = new MediumPublisher({
        accessToken,
        mongoUri: process.env.MONGODB_URI,
        mongoDatabase: process.env.MONGODB_DATABASE || 'neko-defense-system',
        mongoCollection: process.env.MONGODB_COLLECTION || 'medium-publications',
        enableMongoLogging: enableMongo,
      });

      await publisher.initialize();

      // Get user info
      const user = await publisher.getUser();
      console.log(chalk.cyan(`üë§ Authenticated as: ${user.name} (@${user.username})\n`));

      // Publish article
      const result = await publisher.publish(
        article,
        options.source,
        options.generatedBy
      );

      // Display results
      console.log(chalk.green('\n‚ú® Publication successful, desu~! ‚ú®\n'));
      console.log(chalk.cyan('üìä Publication Details:'));
      console.log(chalk.gray('‚îÄ'.repeat(50)));
      console.log(`${chalk.bold('Title:')}        ${result.title}`);
      console.log(`${chalk.bold('URL:')}          ${chalk.blue(result.url)}`);
      console.log(`${chalk.bold('Status:')}       ${result.publishStatus}`);
      console.log(`${chalk.bold('Tags:')}         ${result.tags.join(', ')}`);
      console.log(`${chalk.bold('License:')}      ${result.license}`);
      if (result.publishedAt) {
        console.log(`${chalk.bold('Published At:')} ${new Date(result.publishedAt).toLocaleString()}`);
      }
      console.log(chalk.gray('‚îÄ'.repeat(50)));

      if (enableMongo) {
        console.log(chalk.green('\nüíæ Logged to MongoDB successfully!'));
      }

      console.log(chalk.magenta('\nüêæ Nyaa~! Article published successfully! *purrs* ‚ú®\n'));

      await publisher.cleanup();
      process.exit(0);
    } catch (error) {
      console.error(chalk.red('\n‚ùå Error publishing article:'), error);
      process.exit(1);
    }
  });

/**
 * List publications command
 */
program
  .command('list')
  .description('List all publications from MongoDB')
  .option('-s, --status <status>', 'Filter by status: public, draft, unlisted')
  .action(async (options) => {
    try {
      console.log(chalk.cyan('üêæ Fetching publications from MongoDB, nyaa~!\n'));

      const accessToken = process.env.MEDIUM_ACCESS_TOKEN;
      if (!accessToken) {
        console.error(chalk.red('‚ùå Error: MEDIUM_ACCESS_TOKEN not found in .env file'));
        process.exit(1);
      }

      const publisher = new MediumPublisher({
        accessToken,
        mongoUri: process.env.MONGODB_URI,
        mongoDatabase: process.env.MONGODB_DATABASE || 'neko-defense-system',
        mongoCollection: process.env.MONGODB_COLLECTION || 'medium-publications',
        enableMongoLogging: true,
      });

      await publisher.initialize();

      const publications = options.status
        ? await publisher.getPublicationsByStatus(options.status)
        : await publisher.getPublications();

      console.log(chalk.cyan(`üìö Found ${publications.length} publication(s)\n`));

      publications.forEach((pub, index) => {
        console.log(chalk.gray(`${index + 1}. ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`));
        console.log(`${chalk.bold('Title:')}      ${pub.title}`);
        console.log(`${chalk.bold('URL:')}        ${chalk.blue(pub.url)}`);
        console.log(`${chalk.bold('Status:')}     ${pub.publishStatus}`);
        console.log(`${chalk.bold('Tags:')}       ${pub.tags.join(', ')}`);
        console.log(`${chalk.bold('Source:')}     ${pub.source} (${pub.generatedBy})`);
        console.log(`${chalk.bold('Published:')}  ${pub.publishedAt.toLocaleString()}`);
      });

      console.log(chalk.gray('‚îÄ'.repeat(50)));
      console.log(chalk.magenta('\nüêæ Nyaa~! List complete, desu~! ‚ú®\n'));

      await publisher.cleanup();
      process.exit(0);
    } catch (error) {
      console.error(chalk.red('\n‚ùå Error fetching publications:'), error);
      process.exit(1);
    }
  });

/**
 * Test connection command
 */
program
  .command('test')
  .description('Test Medium API connection and get user info')
  .action(async () => {
    try {
      console.log(chalk.cyan('üêæ Testing Medium API connection, nyaa~!\n'));

      const accessToken = process.env.MEDIUM_ACCESS_TOKEN;
      if (!accessToken) {
        console.error(chalk.red('‚ùå Error: MEDIUM_ACCESS_TOKEN not found in .env file'));
        console.log(chalk.yellow('üí° Get your token at: https://medium.com/me/settings/security'));
        process.exit(1);
      }

      const publisher = new MediumPublisher({
        accessToken,
        enableMongoLogging: false,
      });

      const user = await publisher.getUser();

      console.log(chalk.green('‚úÖ Connection successful!\n'));
      console.log(chalk.cyan('üë§ User Information:'));
      console.log(chalk.gray('‚îÄ'.repeat(50)));
      console.log(`${chalk.bold('Name:')}      ${user.name}`);
      console.log(`${chalk.bold('Username:')}  @${user.username}`);
      console.log(`${chalk.bold('URL:')}       ${chalk.blue(user.url)}`);
      console.log(`${chalk.bold('User ID:')}   ${user.id}`);
      console.log(chalk.gray('‚îÄ'.repeat(50)));
      console.log(chalk.magenta('\nüêæ Nyaa~! Test complete, desu~! ‚ú®\n'));

      process.exit(0);
    } catch (error) {
      console.error(chalk.red('\n‚ùå Error connecting to Medium API:'), error);
      process.exit(1);
    }
  });

program.parse();
